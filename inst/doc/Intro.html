<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="SA22204174" />

<meta name="date" content="2022-12-13" />

<title>Introduction to SA22204174</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Introduction to SA22204174</h1>
<h4 class="author">SA22204174</h4>
<h4 class="date">2022-12-13</h4>



<p>In data analysis we sometimes need to correctly identify clusters
from a heterogeneous population, which is the problem named subgroup
analysis. A popular method for analyzing data from a heterogeneous
population is to view data as coming from a mixture of subgroups with
their own sets of parameter values and then apply finite mixture model
analysis. In this package, two approaches are implemented: the mixture
model approach and the concave pairwise fusion approach, and the
calculation accuracy and speed of these two approaches are compared.</p>
<div id="two-approaches-for-subgroup-analysis" class="section level1">
<h1>Two approaches for subgroup analysis</h1>
</div>
<div id="the-mixture-model-approach" class="section level1">
<h1>The mixture model approach</h1>
<div id="model" class="section level2">
<h2>Model</h2>
<p>Based on the previous researches on mixture model, Fraley and Raftery
(2002) outline a general methodology for model-based clustering that
provides a principled statistical approach to cluster analysis. We
implement the EM iteration for Gaussian mixture models in it.</p>
<p>Given data <span class="math inline">\(\mathbf{X}\)</span> with
independent multivariate observations <span class="math inline">\(\mathbf{x}_1,\dots,\mathbf{x}_n\in\mathbb{R}^p\)</span>,
the likelihood for a mixture model with <span class="math inline">\(K\)</span> components is <span class="math display">\[L_{mix}(\theta_1,\dots,\theta_K;\tau_1,\dots,\tau_K|\mathbf{X})=\prod_{i=1}^n\sum_{k=1}^K\tau_kf_k(\mathbf{x}_i|\mathbf{\theta}_k)\]</span>
where <span class="math inline">\(f_k\)</span> and <span class="math inline">\(\theta_k\)</span> are the density and parameters,
respectively, of the <span class="math inline">\(k\)</span>th component
in the mixture, and <span class="math inline">\(\tau_k\)</span> is the
probability that an observation belongs to the <span class="math inline">\(k\)</span>th component (<span class="math inline">\(\tau_k\geq0;\sum_{k=1}^K=1\)</span>).</p>
<p>Most commonly, <span class="math inline">\(f_k\)</span> is the
multivariate normal (Gaussian) density <span class="math inline">\(\phi_k\)</span>, parametrized by its mean <span class="math inline">\(\mu_k\)</span> and covariance matrix <span class="math inline">\(\Sigma_k\)</span>: <span class="math display">\[\phi_k(\mathbf{x}_i|\theta_k)=\phi_k(\mathbf{x}_i|\mu_k,\Sigma_k)=\frac{\exp\left\{-\frac{1}{2}(\mathbf{x}_i-\mu_k)^T\Sigma_k^{-1}(\mathbf{x}_i-\mu_k)\right\}}{\sqrt{\det(2\pi\Sigma_k)}}.\]</span></p>
</div>
<div id="method" class="section level2">
<h2>Method</h2>
<p>In EM for mixture models, the “complete data” are considered to be
<span class="math inline">\(\mathbf{y}_i=(\mathbf{x}_i,\mathbf{z}_i)\)</span>,
where <span class="math inline">\(\mathbf{z}_i=(z_{i1},\dots,z_{iK})\)</span> is the
unobserved portion of the data, with <span class="math display">\[z_{ik}=\left\{\begin{array}{ll}
1,\quad \text{if}\ \mathbf{x}_i\ \text{belongs to group}\ k,\\
0,\quad \text{otherwise}.
\end{array}\right.\]</span> Assuming that each <span class="math inline">\(\mathbf{z}_i\)</span> is independent and
identically distrubuted according to a multinomial distrubution of one
draw from <span class="math inline">\(K\)</span> probability <span class="math inline">\(\tau_1,\dots,\tau_K\)</span>, and that the density
of an observation <span class="math inline">\(\mathbf{x}_i\)</span>
given <span class="math inline">\(\mathbf{z}_i\)</span> is given by
<span class="math inline">\(\prod_{k=1}^Kf_k(\mathbf{x}_i|\theta_k)^{z_{ik}}\)</span>,
the resulting complete data logarithmic likelihood is <span class="math display">\[l(\theta_k,\tau_k,\Sigma_k,k=1,\dots,K|\mathbf{Y})=\sum_{i=1}^n\sum_{k=1}^Kz_{ik}\log[\tau_kf_k(\mathbf{x}_i|\theta_k)].\]</span>
The idea is to find <span class="math inline">\(\hat\theta_k,\hat\tau_k,\hat\Sigma_k,k=1,\dots,K\)</span>
to maximize the logarithmic likelihood. And then maximum-likelihood
classification of observation <span class="math inline">\(i\)</span> is
<span class="math inline">\(\mathrm{argmax}_{k\in\{1,\dots,K\}}(z_{ik})\)</span>
so that <span class="math inline">\((1-\max_k(z_{ik}))\)</span> is a
measure of the uncertainty in the classification.</p>
</div>
<div id="algorithm" class="section level2">
<h2>Algorithm</h2>
<p>The EM algorithm is as follows.</p>
<ol style="list-style-type: decimal">
<li><p>Initiate <span class="math inline">\(\theta=(\theta_k,\tau_k,\Sigma_k,k=1,\dots,K)\)</span>
with <span class="math inline">\(\hat\theta=(\hat\mu_k,\hat\tau_k,\hat\Sigma_k,k=1,\dots,K)\)</span>.</p></li>
<li><p>E-step: the conditional expectation <span class="math inline">\(\hat{\mathbf{Z}}\)</span> of <span class="math inline">\(\mathbf{Z}\)</span> is <span class="math display">\[\hat{z}_{ik}=\frac{\hat{\tau}_kf_k(\mathbf{x}_i|\hat{\theta}_k)}{\sum_{j=1}^K\hat{\tau}_jf_j(\mathbf{x}_i|\hat{\theta}_j)}.\]</span></p></li>
<li><p>M-step: maximize <span class="math display">\[l(\theta_k,\tau_k,\Sigma_k,k=1,\dots,K|\mathbf{Y})=\sum_{i=1}^n\sum_{k=1}^Kz_{ik}\log[\tau_kf_k(\mathbf{x}_i|\theta_k)]=\sum_{i=1}^n\sum_{k=1}^Kz_{ik}\left(\log\tau_k-\frac{p}{2}\log(2\pi)-\frac{1}{2}\log(\det(\Sigma_k))-\frac{1}{2}(\mathbf{x}_i-\mu_k)^T\Sigma_k^{-1}(\mathbf{x}_i-\mu_k)\right).\]</span>
w.r.t. <span class="math inline">\(\theta=(\mu,\tau,\Sigma)\)</span>.
The resulting maximizers are <span class="math display">\[{n}_k=\sum_{i=1}^n\hat{z}_{ik},\quad
\hat\tau_k=\frac{\hat n_k}{n},\quad
\hat\mu_k=\frac{\sum_{i=1}^n\hat{z}_{ik}\mathbf{x}_i}{n_k},\quad
\hat\Sigma_k=\frac{W_k}{n_k}=\frac{\sum_{i=1}^n\hat{z}_{ik}(\mathbf{x}_i-\hat\mu_k)(\mathbf{x}_i-\hat\mu_k)^T}{n_k}.\]</span></p></li>
<li><p>Repeat steps 2 and 3 until the sequence <span class="math inline">\(\theta\)</span> convergence.</p></li>
</ol>
</div>
<div id="r-function" class="section level2">
<h2>R Function</h2>
<p>There is a R function to implement the mixture model approach.</p>
<ul>
<li>Input:
<ul>
<li>X: the random samples generated from a Gaussian mixture model, data
structure: <span class="math inline">\(n\times p\)</span>-dimensional
matrix.</li>
<li>K: the number of mixture components in the population, data
structure: int.</li>
<li>times: the upper bound on the number of iterations, data structure:
int.</li>
<li>initial.tau: initial value of tau, data structure: <span class="math inline">\(K\)</span>-dimensional vector.</li>
<li>initial.mu: initial value of mu, data structure: <span class="math inline">\(p\times K\)</span>-dimensional matrix, or <span class="math inline">\(K\)</span>-dimensional vector (when <span class="math inline">\(p\)</span>=1).</li>
<li>initial.sigma: initial value, data structure: <span class="math inline">\(p\times p\times K\)</span>-dimensional array, or
<span class="math inline">\(K\)</span>-dimensional vector (when <span class="math inline">\(p\)</span>=1).</li>
</ul></li>
<li>Output: a list including
<ul>
<li>iterations: the number of iterations, data structure: int.</li>
<li>tau: the estimate of the proportion of each cluster, data structure:
<span class="math inline">\(K\)</span>-dimensional vector.</li>
<li>mu: the estimate of <span class="math inline">\(\mu\)</span> in each
cluster, data structure: <span class="math inline">\(p\times
K\)</span>-dimensional matrix.</li>
<li>sigma: the estimate of <span class="math inline">\(\Sigma\)</span>
in each cluster, data structure: <span class="math inline">\(p\times
p\times K\)</span>-dimensional array.</li>
</ul></li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>mixmodel_R <span class="ot">&lt;-</span> <span class="cf">function</span>(X, K, <span class="at">times =</span> <span class="fl">1e4</span>, initial.tau, initial.mu, initial.sigma){</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>  <span class="co">#X: the random samples generated from a Gaussian mixture model, data structure: n*p-dimensional matrix, n-dimensional vector(p=1)</span></span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a>  <span class="co">#K: the number of mixture components in the population, data structure: int</span></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>  <span class="co">#times: the upper bound on the number of iterations, data structure: int</span></span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a>  <span class="co">#initial.tau: initial value of tau, data structure: K-dimensional vector</span></span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a>  <span class="co">#initial.mu: initial value of mu, data structure: p*K-dimensional matrix, K-dimensional vector(p=1)</span></span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a>  <span class="co">#initial.sigma: initial value of sigma, data structure: p*p*K-dimensional array, K-dimensional vector(p=1)</span></span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a>  n <span class="ot">&lt;-</span> <span class="fu">nrow</span>(X); p <span class="ot">&lt;-</span> <span class="fu">ncol</span>(X)<span class="co">#n: sample size, p: the dimension of random vectors</span></span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a>  tau <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="dv">0</span>, <span class="at">nrow =</span> K, <span class="at">ncol =</span> times<span class="sc">+</span><span class="dv">1</span>)<span class="co">#the chains from iteration</span></span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a>  mu <span class="ot">&lt;-</span> <span class="fu">array</span>(<span class="dv">0</span>, <span class="at">dim =</span> <span class="fu">c</span>(p, K, times<span class="sc">+</span><span class="dv">1</span>))</span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a>  sigma <span class="ot">&lt;-</span> <span class="fu">array</span>(<span class="dv">0</span>, <span class="at">dim =</span> <span class="fu">c</span>(p, p, K, times<span class="sc">+</span><span class="dv">1</span>))</span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a>  z <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="dv">0</span>, <span class="at">nrow =</span> n, <span class="at">ncol =</span> K)</span>
<span id="cb1-13"><a href="#cb1-13" tabindex="-1"></a>  rate <span class="ot">&lt;-</span> <span class="fl">1e-8</span> <span class="co">#Convergence is checked when the change of elements in the sequence is small enough</span></span>
<span id="cb1-14"><a href="#cb1-14" tabindex="-1"></a>  </span>
<span id="cb1-15"><a href="#cb1-15" tabindex="-1"></a>  <span class="co">#initialization</span></span>
<span id="cb1-16"><a href="#cb1-16" tabindex="-1"></a>  tau[,<span class="dv">1</span>] <span class="ot">&lt;-</span> initial.tau</span>
<span id="cb1-17"><a href="#cb1-17" tabindex="-1"></a>  mu[,,<span class="dv">1</span>] <span class="ot">&lt;-</span> initial.mu</span>
<span id="cb1-18"><a href="#cb1-18" tabindex="-1"></a>  sigma[,,,<span class="dv">1</span>] <span class="ot">&lt;-</span> initial.sigma</span>
<span id="cb1-19"><a href="#cb1-19" tabindex="-1"></a>  </span>
<span id="cb1-20"><a href="#cb1-20" tabindex="-1"></a>  <span class="co">#EM iteration</span></span>
<span id="cb1-21"><a href="#cb1-21" tabindex="-1"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>times){</span>
<span id="cb1-22"><a href="#cb1-22" tabindex="-1"></a>    <span class="cf">for</span>(k <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>K){</span>
<span id="cb1-23"><a href="#cb1-23" tabindex="-1"></a><span class="co">#      zk &lt;- apply(X, 1, function(x) exp(-(x-mu[,k,i])%*%solve(sigma[,,k,i])%*%(x-mu[,k,i])/2)/sqrt(2*pi*det(sigma[,,k,i])) )</span></span>
<span id="cb1-24"><a href="#cb1-24" tabindex="-1"></a>      <span class="cf">if</span>(p <span class="sc">&gt;</span> <span class="dv">1</span>){</span>
<span id="cb1-25"><a href="#cb1-25" tabindex="-1"></a>      zk <span class="ot">&lt;-</span> <span class="fu">apply</span>(X, <span class="dv">1</span>, <span class="cf">function</span>(x) mvtnorm<span class="sc">::</span><span class="fu">dmvnorm</span>(x, <span class="at">mean =</span> mu[,k,i], <span class="at">sigma =</span> sigma[,,k,i]))</span>
<span id="cb1-26"><a href="#cb1-26" tabindex="-1"></a>      }<span class="cf">else</span>{</span>
<span id="cb1-27"><a href="#cb1-27" tabindex="-1"></a>      zk <span class="ot">&lt;-</span> <span class="fu">dnorm</span>(X, <span class="at">mean =</span> mu[,k,i], <span class="at">sd =</span> <span class="fu">sqrt</span>(sigma[,,k,i]))</span>
<span id="cb1-28"><a href="#cb1-28" tabindex="-1"></a>      }<span class="co">#n-dimension</span></span>
<span id="cb1-29"><a href="#cb1-29" tabindex="-1"></a>      z[,k] <span class="ot">&lt;-</span> tau[k,i]<span class="sc">*</span>zk<span class="co">#n-dimension</span></span>
<span id="cb1-30"><a href="#cb1-30" tabindex="-1"></a>    }</span>
<span id="cb1-31"><a href="#cb1-31" tabindex="-1"></a>    z_column <span class="ot">&lt;-</span> <span class="fu">apply</span>(z, <span class="dv">1</span>, sum)<span class="co">#n-dimension</span></span>
<span id="cb1-32"><a href="#cb1-32" tabindex="-1"></a>    z <span class="ot">&lt;-</span> z<span class="sc">/</span>z_column</span>
<span id="cb1-33"><a href="#cb1-33" tabindex="-1"></a>    nhat <span class="ot">&lt;-</span> <span class="fu">apply</span>(z, <span class="dv">2</span>, sum)<span class="co">#K-dimension</span></span>
<span id="cb1-34"><a href="#cb1-34" tabindex="-1"></a>    tau[,i<span class="sc">+</span><span class="dv">1</span>] <span class="ot">&lt;-</span> nhat<span class="sc">/</span>n</span>
<span id="cb1-35"><a href="#cb1-35" tabindex="-1"></a>    <span class="cf">for</span>(k <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>K){</span>
<span id="cb1-36"><a href="#cb1-36" tabindex="-1"></a>      mu[,k,i<span class="sc">+</span><span class="dv">1</span>] <span class="ot">&lt;-</span> <span class="fu">apply</span>(z[,k]<span class="sc">*</span>X, <span class="dv">2</span>, sum)<span class="sc">/</span>nhat[k]<span class="co">#p-dimension</span></span>
<span id="cb1-37"><a href="#cb1-37" tabindex="-1"></a>      sigma[,,k,i<span class="sc">+</span><span class="dv">1</span>] <span class="ot">&lt;-</span> <span class="fu">t</span>(X<span class="sc">-</span><span class="fu">matrix</span>(<span class="dv">1</span>,n,<span class="dv">1</span>)<span class="sc">%*%</span>mu[,k,i<span class="sc">+</span><span class="dv">1</span>])<span class="sc">%*%</span><span class="fu">diag</span>(z[,k])<span class="sc">%*%</span>(X<span class="sc">-</span><span class="fu">matrix</span>(<span class="dv">1</span>,n,<span class="dv">1</span>)<span class="sc">%*%</span>mu[,k,i<span class="sc">+</span><span class="dv">1</span>])<span class="sc">/</span>nhat[k]<span class="co">#(p*n)*(n*n)*(n*p)=p*p-dimension</span></span>
<span id="cb1-38"><a href="#cb1-38" tabindex="-1"></a>    }</span>
<span id="cb1-39"><a href="#cb1-39" tabindex="-1"></a>    <span class="co">#cat(&quot;step=&quot;, i, &quot;tau=&quot;, tau[,i+1], &quot;mu=&quot;, mu[,,i+1], &quot;sigma=&quot;, sigma[,,,i+1], &#39;\n&#39;)</span></span>
<span id="cb1-40"><a href="#cb1-40" tabindex="-1"></a>    <span class="cf">if</span> (<span class="fu">max</span>( <span class="fu">sum</span>(<span class="fu">abs</span>(tau[,i<span class="sc">+</span><span class="dv">1</span>] <span class="sc">-</span> tau[,i]))<span class="sc">/</span><span class="fu">sum</span>(<span class="fu">abs</span>(tau[,i])), <span class="fu">sum</span>(<span class="fu">abs</span>(mu[,,i<span class="sc">+</span><span class="dv">1</span>]<span class="sc">-</span>mu[,,i]))<span class="sc">/</span><span class="fu">sum</span>(<span class="fu">abs</span>(mu[,,i])), <span class="fu">sum</span>(<span class="fu">abs</span>(sigma[,,,i<span class="sc">+</span><span class="dv">1</span>]<span class="sc">-</span>sigma[,,,i]))<span class="sc">/</span><span class="fu">sum</span>(<span class="fu">abs</span>(sigma[,,,i])) ) <span class="sc">&lt;</span> rate){</span>
<span id="cb1-41"><a href="#cb1-41" tabindex="-1"></a>      <span class="co">#cat(&quot;The sequence converges after&quot;, i, &quot;iterations.&quot;, &#39;\n&#39;)</span></span>
<span id="cb1-42"><a href="#cb1-42" tabindex="-1"></a>      <span class="cf">break</span></span>
<span id="cb1-43"><a href="#cb1-43" tabindex="-1"></a>    }</span>
<span id="cb1-44"><a href="#cb1-44" tabindex="-1"></a>  }</span>
<span id="cb1-45"><a href="#cb1-45" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">list</span>(<span class="at">iterations =</span> i, <span class="at">tau =</span> tau[,i<span class="sc">+</span><span class="dv">1</span>], <span class="at">mu =</span> mu[,,i<span class="sc">+</span><span class="dv">1</span>], <span class="at">sigma =</span> sigma[,,,i<span class="sc">+</span><span class="dv">1</span>]))</span>
<span id="cb1-46"><a href="#cb1-46" tabindex="-1"></a>}</span></code></pre></div>
</div>
<div id="example-for-r-function" class="section level2">
<h2>Example for R function</h2>
<div id="example-1." class="section level3">
<h3>Example 1.</h3>
<p><span class="math inline">\(n=500,p=2,K=3\)</span>, <span class="math inline">\(\mu_1=(-2,-1),\mu_2=(0,4),\mu_3=(3,1)\)</span>,
<span class="math inline">\(P(\mu=\mu_1)=1/3, P(\mu=\mu_2)=1/3,
P(\mu=\mu_3)=1/3\)</span> and <span class="math inline">\(\Sigma\)</span> satisfies that <span class="math inline">\(\Sigma_{ii}=1, \Sigma_{ij}=0.3, i\neq
j\in\{1,2\}\)</span>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="co">#parameters of the samples</span></span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>n <span class="ot">&lt;-</span> <span class="dv">500</span>; p <span class="ot">&lt;-</span> <span class="dv">2</span>; K <span class="ot">&lt;-</span> <span class="dv">3</span></span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>mu <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="sc">-</span><span class="dv">2</span>,<span class="sc">-</span><span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">1</span>), <span class="at">nrow =</span> p, <span class="at">ncol =</span> K)</span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a>sigma <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fl">0.3</span>, <span class="at">nrow =</span> p, <span class="at">ncol =</span> p) <span class="sc">+</span> <span class="fu">diag</span>(<span class="fl">0.7</span>, p)</span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a><span class="co">#generate the random samples</span></span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a>X <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="dv">0</span>, <span class="at">nrow =</span> n, <span class="at">ncol =</span> p)</span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a>select <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>, <span class="at">size =</span> n, <span class="at">replace =</span> <span class="cn">TRUE</span>, <span class="at">prob =</span> <span class="fu">c</span>(<span class="dv">1</span><span class="sc">/</span><span class="dv">3</span>,<span class="dv">1</span><span class="sc">/</span><span class="dv">3</span>,<span class="dv">1</span><span class="sc">/</span><span class="dv">3</span>))</span>
<span id="cb2-10"><a href="#cb2-10" tabindex="-1"></a>X[select<span class="sc">==</span><span class="dv">1</span>,] <span class="ot">&lt;-</span> mvtnorm<span class="sc">::</span><span class="fu">rmvnorm</span>(<span class="fu">sum</span>(select<span class="sc">==</span><span class="dv">1</span>), <span class="at">mean =</span> mu[,<span class="dv">1</span>], <span class="at">sigma =</span> sigma)</span>
<span id="cb2-11"><a href="#cb2-11" tabindex="-1"></a>X[select<span class="sc">==</span><span class="dv">2</span>,] <span class="ot">&lt;-</span> mvtnorm<span class="sc">::</span><span class="fu">rmvnorm</span>(<span class="fu">sum</span>(select<span class="sc">==</span><span class="dv">2</span>), <span class="at">mean =</span> mu[,<span class="dv">2</span>], <span class="at">sigma =</span> sigma)</span>
<span id="cb2-12"><a href="#cb2-12" tabindex="-1"></a>X[select<span class="sc">==</span><span class="dv">3</span>,] <span class="ot">&lt;-</span> mvtnorm<span class="sc">::</span><span class="fu">rmvnorm</span>(<span class="fu">sum</span>(select<span class="sc">==</span><span class="dv">3</span>), <span class="at">mean =</span> mu[,<span class="dv">3</span>], <span class="at">sigma =</span> sigma)</span></code></pre></div>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="co">#initialization</span></span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>initial.tau <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="dv">1</span><span class="sc">/</span>K, K)</span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>initial.mu <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="sc">-</span><span class="dv">2</span>,<span class="sc">-</span><span class="dv">2</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">2</span>), <span class="at">nrow =</span> p, <span class="at">ncol =</span> K)</span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a>initial.sigma <span class="ot">&lt;-</span> <span class="fu">array</span>(<span class="fu">rep</span>(<span class="fu">cov</span>(X), K), <span class="at">dim =</span> <span class="fu">c</span>(p,p,K))</span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a><span class="co">#cluster analysis</span></span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a><span class="fu">mixmodel_R</span>(X, K, <span class="at">times =</span> <span class="dv">500</span>, initial.tau, initial.mu, initial.sigma)</span></code></pre></div>
<pre><code>## $iterations
## [1] 130
## 
## $tau
## [1] 0.3150728 0.3382793 0.3466479
## 
## $mu
##            [,1]        [,2]      [,3]
## [1,] -2.0624715 -0.03125913 3.0370915
## [2,] -0.9624836  3.88462975 0.9185865
## 
## $sigma
## , , 1
## 
##           [,1]      [,2]
## [1,] 1.1328541 0.2444585
## [2,] 0.2444585 0.8688239
## 
## , , 2
## 
##          [,1]     [,2]
## [1,] 1.199305 0.363013
## [2,] 0.363013 1.303373
## 
## , , 3
## 
##           [,1]      [,2]
## [1,] 0.9896885 0.3740238
## [2,] 0.3740238 1.0137451</code></pre>
</div>
<div id="example-2." class="section level3">
<h3>Example 2.</h3>
<p><span class="math inline">\(n=300,p=1,K=3\)</span>, <span class="math inline">\(\mu_1=-2,\mu_2=0,\mu_3=3\)</span>, <span class="math inline">\(P(\mu=\mu_1)=0.3, P(\mu=\mu_2)=0.2,
P(\mu=\mu_3)=0.5\)</span> and <span class="math inline">\(\Sigma=1\)</span>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="co">#parameters of the samples</span></span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>n <span class="ot">&lt;-</span> <span class="dv">300</span>; p <span class="ot">&lt;-</span> <span class="dv">1</span>; K <span class="ot">&lt;-</span> <span class="dv">3</span></span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>mu <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">3</span>)</span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a>sigma <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a><span class="co">#generate the random samples</span></span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a>X <span class="ot">&lt;-</span> <span class="fu">numeric</span>(n)</span>
<span id="cb5-8"><a href="#cb5-8" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb5-9"><a href="#cb5-9" tabindex="-1"></a>select <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>, <span class="at">size =</span> n, <span class="at">replace =</span> <span class="cn">TRUE</span>, <span class="at">prob =</span> <span class="fu">c</span>(<span class="fl">0.3</span>,<span class="fl">0.2</span>,<span class="fl">0.5</span>))</span>
<span id="cb5-10"><a href="#cb5-10" tabindex="-1"></a>X[select<span class="sc">==</span><span class="dv">1</span>] <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(<span class="fu">sum</span>(select<span class="sc">==</span><span class="dv">1</span>), <span class="at">mean =</span> mu[<span class="dv">1</span>], <span class="at">sd =</span> <span class="fu">sqrt</span>(sigma))</span>
<span id="cb5-11"><a href="#cb5-11" tabindex="-1"></a>X[select<span class="sc">==</span><span class="dv">2</span>] <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(<span class="fu">sum</span>(select<span class="sc">==</span><span class="dv">2</span>), <span class="at">mean =</span> mu[<span class="dv">2</span>], <span class="at">sd =</span> <span class="fu">sqrt</span>(sigma))</span>
<span id="cb5-12"><a href="#cb5-12" tabindex="-1"></a>X[select<span class="sc">==</span><span class="dv">3</span>] <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(<span class="fu">sum</span>(select<span class="sc">==</span><span class="dv">3</span>), <span class="at">mean =</span> mu[<span class="dv">3</span>], <span class="at">sd =</span> <span class="fu">sqrt</span>(sigma))</span></code></pre></div>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="co">#initialization</span></span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>initial.tau <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="dv">1</span><span class="sc">/</span>K, K)</span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a>initial.mu <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="sc">-</span><span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>), <span class="at">nrow =</span> p, <span class="at">ncol =</span> K)</span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a>initial.sigma <span class="ot">&lt;-</span> <span class="fu">array</span>(<span class="fu">rep</span>(<span class="fu">var</span>(X), K), <span class="at">dim =</span> <span class="fu">c</span>(p,p,K))</span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a><span class="co">#cluster analysis</span></span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a><span class="fu">mixmodel_R</span>(<span class="fu">matrix</span>(X, <span class="at">nrow =</span> n, <span class="at">ncol =</span> p), K, <span class="fl">1e4</span>, initial.tau, initial.mu, initial.sigma)</span></code></pre></div>
<pre><code>## $iterations
## [1] 1519
## 
## $tau
## [1] 0.3188513 0.1908240 0.4903247
## 
## $mu
## [1] -1.9653389  0.4520905  3.1680911
## 
## $sigma
## [1] 1.0433739 0.7609533 0.7668253</code></pre>
</div>
</div>
<div id="rcpp-function" class="section level2">
<h2>Rcpp function</h2>
<p>There is a R function to implement the mixture model approach when
<span class="math inline">\(p=1\)</span>.</p>
<ul>
<li>Input:
<ul>
<li>X: the random samples generated from a Gaussian mixture model, data
structure: <span class="math inline">\(n\)</span>-dimensional
vector.</li>
<li>K: the number of mixture components in the population, data
structure: int.</li>
<li>times: the upper bound on the number of iterations, data structure:
int.</li>
<li>initial_tau: initial value of tau, data structure: <span class="math inline">\(K\)</span>-dimensional vector.</li>
<li>initial_mu: initial value of mu, data structure: <span class="math inline">\(K\)</span>-dimensional vector (<span class="math inline">\(p\)</span>=1).</li>
<li>initial_sigma: initial value of sigma, data structure: <span class="math inline">\(K\)</span>-dimensional vector (<span class="math inline">\(p\)</span>=1).</li>
</ul></li>
<li>Output: a list including
<ul>
<li>iterations: the number of iterations, data structure: int.</li>
<li>tau: the estimate of the proportion of each cluster, data structure:
<span class="math inline">\(K\)</span>-dimensional vector.</li>
<li>mu: the estimate of <span class="math inline">\(\mu\)</span> in each
cluster, data structure: <span class="math inline">\(K\)</span>-dimensional vector.</li>
<li>sigma: the estimate of <span class="math inline">\(\Sigma\)</span>
in each cluster, data structure: <span class="math inline">\(K\)</span>-dimensional vector.</li>
</ul></li>
</ul>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="pp"># include </span><span class="im">&lt;Rcpp.h&gt;</span></span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a>using namespace Rcpp<span class="op">;</span></span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a><span class="co">// [[Rcpp::export]]</span></span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a>List mixmodel_Rcpp<span class="op">(</span>NumericVector X<span class="op">,</span> <span class="dt">int</span> K<span class="op">,</span> <span class="dt">int</span> times<span class="op">,</span> NumericVector initial_tau<span class="op">,</span> NumericVector initial_mu<span class="op">,</span> NumericVector initial_sigma<span class="op">){</span></span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a>  <span class="co">//X: the random samples generated from a Gaussian mixture model, data structure: matrix, nrow = sample size, ncol = the dimension of random vectors</span></span>
<span id="cb8-7"><a href="#cb8-7" tabindex="-1"></a>  <span class="co">//K: the number of mixture components in the population, data structure: int</span></span>
<span id="cb8-8"><a href="#cb8-8" tabindex="-1"></a>  <span class="co">//times: the upper bound on the number of iterations, data structure: int</span></span>
<span id="cb8-9"><a href="#cb8-9" tabindex="-1"></a>  <span class="dt">int</span> n <span class="op">=</span> X<span class="op">.</span>size<span class="op">();</span> <span class="co">//n: sample size, p: the dimension of random vectors</span></span>
<span id="cb8-10"><a href="#cb8-10" tabindex="-1"></a>  NumericMatrix tau<span class="op">(</span>K<span class="op">,</span> times<span class="op">+</span><span class="dv">1</span><span class="op">),</span> mu<span class="op">(</span>K<span class="op">,</span> times<span class="op">+</span><span class="dv">1</span><span class="op">),</span> sigma<span class="op">(</span>K<span class="op">,</span> times<span class="op">+</span><span class="dv">1</span><span class="op">);</span><span class="co">//the chains from iteration</span></span>
<span id="cb8-11"><a href="#cb8-11" tabindex="-1"></a>  NumericMatrix z<span class="op">(</span>n<span class="op">,</span> K<span class="op">);</span> NumericVector zk<span class="op">(</span>n<span class="op">),</span> z_column<span class="op">(</span>n<span class="op">),</span> nhat<span class="op">(</span>K<span class="op">);</span></span>
<span id="cb8-12"><a href="#cb8-12" tabindex="-1"></a>  <span class="dt">double</span> rate <span class="op">=</span> <span class="fl">1e-8</span><span class="op">;</span> <span class="co">//Convergence is checked when the change of elements in the sequence is small enough</span></span>
<span id="cb8-13"><a href="#cb8-13" tabindex="-1"></a>  </span>
<span id="cb8-14"><a href="#cb8-14" tabindex="-1"></a>  <span class="co">//initialization</span></span>
<span id="cb8-15"><a href="#cb8-15" tabindex="-1"></a>  tau<span class="op">.</span>column<span class="op">(</span><span class="dv">0</span><span class="op">)</span> <span class="op">=</span> initial_tau<span class="op">;</span></span>
<span id="cb8-16"><a href="#cb8-16" tabindex="-1"></a>  mu<span class="op">.</span>column<span class="op">(</span><span class="dv">0</span><span class="op">)</span> <span class="op">=</span> initial_mu<span class="op">;</span></span>
<span id="cb8-17"><a href="#cb8-17" tabindex="-1"></a>  sigma<span class="op">.</span>column<span class="op">(</span><span class="dv">0</span><span class="op">)</span> <span class="op">=</span> initial_sigma<span class="op">;</span></span>
<span id="cb8-18"><a href="#cb8-18" tabindex="-1"></a> </span>
<span id="cb8-19"><a href="#cb8-19" tabindex="-1"></a>  <span class="co">//EM iteration</span></span>
<span id="cb8-20"><a href="#cb8-20" tabindex="-1"></a>  <span class="dt">int</span> t<span class="op">;</span><span class="co">//counternumber</span></span>
<span id="cb8-21"><a href="#cb8-21" tabindex="-1"></a>  <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span> i<span class="op">&lt;</span>times<span class="op">;</span> i<span class="op">++){</span></span>
<span id="cb8-22"><a href="#cb8-22" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> k<span class="op">=</span><span class="dv">0</span><span class="op">;</span> k<span class="op">&lt;</span>K<span class="op">;</span> k<span class="op">++){</span></span>
<span id="cb8-23"><a href="#cb8-23" tabindex="-1"></a>      zk <span class="op">=</span> Rcpp<span class="op">::</span>dnorm<span class="op">(</span>X<span class="op">,</span> mu<span class="op">(</span>k<span class="op">,</span>i<span class="op">),</span> sqrt<span class="op">(</span>sigma<span class="op">(</span>k<span class="op">,</span>i<span class="op">)));</span><span class="co">//n-dimension</span></span>
<span id="cb8-24"><a href="#cb8-24" tabindex="-1"></a>      z<span class="op">.</span>column<span class="op">(</span>k<span class="op">)</span> <span class="op">=</span> tau<span class="op">(</span>k<span class="op">,</span>i<span class="op">)*</span>zk<span class="op">;</span><span class="co">//n-dimension</span></span>
<span id="cb8-25"><a href="#cb8-25" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-26"><a href="#cb8-26" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> j<span class="op">=</span><span class="dv">0</span><span class="op">;</span> j<span class="op">&lt;</span>n<span class="op">;</span> j<span class="op">++){</span></span>
<span id="cb8-27"><a href="#cb8-27" tabindex="-1"></a>      z_column<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> sum<span class="op">(</span>z<span class="op">.</span>row<span class="op">(</span>j<span class="op">));</span></span>
<span id="cb8-28"><a href="#cb8-28" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-29"><a href="#cb8-29" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> k<span class="op">=</span><span class="dv">0</span><span class="op">;</span> k<span class="op">&lt;</span>K<span class="op">;</span> k<span class="op">++){</span></span>
<span id="cb8-30"><a href="#cb8-30" tabindex="-1"></a>      z<span class="op">.</span>column<span class="op">(</span>k<span class="op">)</span> <span class="op">=</span> z<span class="op">.</span>column<span class="op">(</span>k<span class="op">)/</span>z_column<span class="op">;</span><span class="co">//n-dimension</span></span>
<span id="cb8-31"><a href="#cb8-31" tabindex="-1"></a>      nhat<span class="op">[</span>k<span class="op">]</span> <span class="op">=</span> sum<span class="op">(</span>z<span class="op">.</span>column<span class="op">(</span>k<span class="op">));</span></span>
<span id="cb8-32"><a href="#cb8-32" tabindex="-1"></a>      tau<span class="op">(</span>k<span class="op">,</span> i<span class="op">+</span><span class="dv">1</span><span class="op">)</span> <span class="op">=</span> nhat<span class="op">[</span>k<span class="op">]/</span>n<span class="op">;</span></span>
<span id="cb8-33"><a href="#cb8-33" tabindex="-1"></a>      mu<span class="op">(</span>k<span class="op">,</span> i<span class="op">+</span><span class="dv">1</span><span class="op">)</span> <span class="op">=</span> sum<span class="op">(</span>z<span class="op">.</span>column<span class="op">(</span>k<span class="op">)*</span>X<span class="op">)/</span>nhat<span class="op">[</span>k<span class="op">];</span><span class="co">//p-dimension</span></span>
<span id="cb8-34"><a href="#cb8-34" tabindex="-1"></a>      sigma<span class="op">(</span>k<span class="op">,</span> i<span class="op">+</span><span class="dv">1</span><span class="op">)</span> <span class="op">=</span> sum<span class="op">((</span>X<span class="op">-</span>mu<span class="op">(</span>k<span class="op">,</span> i<span class="op">+</span><span class="dv">1</span><span class="op">))*</span>z<span class="op">.</span>column<span class="op">(</span>k<span class="op">)*(</span>X<span class="op">-</span>mu<span class="op">(</span>k<span class="op">,</span> i<span class="op">+</span><span class="dv">1</span><span class="op">)))/</span>nhat<span class="op">[</span>k<span class="op">];</span><span class="co">//(p*n)*(n*n)*(n*p)=p*p-dimension</span></span>
<span id="cb8-35"><a href="#cb8-35" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-36"><a href="#cb8-36" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span> <span class="op">((</span>sum<span class="op">(</span>abs<span class="op">(</span>tau<span class="op">(</span>_<span class="op">,</span>i<span class="op">+</span><span class="dv">1</span><span class="op">)-</span>tau<span class="op">(</span>_<span class="op">,</span>i<span class="op">)))/</span>sum<span class="op">(</span>abs<span class="op">(</span>tau<span class="op">(</span>_<span class="op">,</span>i<span class="op">))))&lt;</span>rate<span class="op">)</span> <span class="op">&amp;</span> <span class="op">((</span>sum<span class="op">(</span>abs<span class="op">(</span>mu<span class="op">(</span>_<span class="op">,</span>i<span class="op">+</span><span class="dv">1</span><span class="op">)-</span>mu<span class="op">(</span>_<span class="op">,</span>i<span class="op">)))/</span>sum<span class="op">(</span>abs<span class="op">(</span>mu<span class="op">(</span>_<span class="op">,</span>i<span class="op">))))&lt;</span>rate<span class="op">)</span> <span class="op">&amp;</span> <span class="op">((</span>sum<span class="op">(</span>abs<span class="op">(</span>sigma<span class="op">(</span>_<span class="op">,</span>i<span class="op">+</span><span class="dv">1</span><span class="op">)-</span>sigma<span class="op">(</span>_<span class="op">,</span>i<span class="op">)))/</span>sum<span class="op">(</span>abs<span class="op">(</span>sigma<span class="op">(</span>_<span class="op">,</span>i<span class="op">))))&lt;</span>rate<span class="op">)</span> <span class="op">){</span></span>
<span id="cb8-37"><a href="#cb8-37" tabindex="-1"></a>      <span class="co">//print( List::create(Named(&quot;The sequence converges after the number of iterations = &quot;)=i+1));</span></span>
<span id="cb8-38"><a href="#cb8-38" tabindex="-1"></a>      t <span class="op">=</span> i<span class="op">+</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb8-39"><a href="#cb8-39" tabindex="-1"></a>      <span class="cf">break</span><span class="op">;</span></span>
<span id="cb8-40"><a href="#cb8-40" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-41"><a href="#cb8-41" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb8-42"><a href="#cb8-42" tabindex="-1"></a>  <span class="cf">return</span><span class="op">(</span>List<span class="op">::</span>create<span class="op">(</span>Named<span class="op">(</span><span class="st">&quot;iterations&quot;</span><span class="op">)</span> <span class="op">=</span> t<span class="op">,</span> Named<span class="op">(</span><span class="st">&quot;tau&quot;</span><span class="op">)</span> <span class="op">=</span> tau<span class="op">(</span>_<span class="op">,</span>t<span class="op">),</span> Named<span class="op">(</span><span class="st">&quot;mu&quot;</span><span class="op">)</span> <span class="op">=</span> mu<span class="op">(</span>_<span class="op">,</span>t<span class="op">),</span> Named<span class="op">(</span><span class="st">&quot;sigma&quot;</span><span class="op">)</span> <span class="op">=</span> sigma<span class="op">(</span>_<span class="op">,</span>t<span class="op">)));</span></span>
<span id="cb8-43"><a href="#cb8-43" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<div id="example-for-rcpp-function" class="section level2">
<h2>Example for Rcpp function</h2>
<p><span class="math inline">\(n=300,p=1,K=3\)</span>, <span class="math inline">\(\mu_1=-2,\mu_2=0,\mu_3=3\)</span>, <span class="math inline">\(P(\mu=\mu_1)=0.3, P(\mu=\mu_2)=0.2,
P(\mu=\mu_3)=0.5\)</span> and <span class="math inline">\(\Sigma=1\)</span>.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="co">#parameters of the samples</span></span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>n <span class="ot">&lt;-</span> <span class="dv">300</span>; p <span class="ot">&lt;-</span> <span class="dv">1</span>; K <span class="ot">&lt;-</span> <span class="dv">3</span></span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>mu <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">3</span>)</span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a>sigma <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" tabindex="-1"></a><span class="co">#generate the random samples</span></span>
<span id="cb9-7"><a href="#cb9-7" tabindex="-1"></a>X <span class="ot">&lt;-</span> <span class="fu">numeric</span>(n)</span>
<span id="cb9-8"><a href="#cb9-8" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb9-9"><a href="#cb9-9" tabindex="-1"></a>select <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>, <span class="at">size =</span> n, <span class="at">replace =</span> <span class="cn">TRUE</span>, <span class="at">prob =</span> <span class="fu">c</span>(<span class="fl">0.3</span>,<span class="fl">0.2</span>,<span class="fl">0.5</span>))</span>
<span id="cb9-10"><a href="#cb9-10" tabindex="-1"></a>X[select<span class="sc">==</span><span class="dv">1</span>] <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(<span class="fu">sum</span>(select<span class="sc">==</span><span class="dv">1</span>), <span class="at">mean =</span> mu[<span class="dv">1</span>], <span class="at">sd =</span> <span class="fu">sqrt</span>(sigma))</span>
<span id="cb9-11"><a href="#cb9-11" tabindex="-1"></a>X[select<span class="sc">==</span><span class="dv">2</span>] <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(<span class="fu">sum</span>(select<span class="sc">==</span><span class="dv">2</span>), <span class="at">mean =</span> mu[<span class="dv">2</span>], <span class="at">sd =</span> <span class="fu">sqrt</span>(sigma))</span>
<span id="cb9-12"><a href="#cb9-12" tabindex="-1"></a>X[select<span class="sc">==</span><span class="dv">3</span>] <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(<span class="fu">sum</span>(select<span class="sc">==</span><span class="dv">3</span>), <span class="at">mean =</span> mu[<span class="dv">3</span>], <span class="at">sd =</span> <span class="fu">sqrt</span>(sigma))</span></code></pre></div>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="co">#initialization</span></span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>initial_tau <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="dv">1</span><span class="sc">/</span>K, K)</span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a>initial_mu <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a>initial_sigma <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="fu">var</span>(X),K)</span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a><span class="co">#cluster analysis</span></span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a><span class="fu">library</span>(Rcpp)</span>
<span id="cb10-7"><a href="#cb10-7" tabindex="-1"></a><span class="fu">sourceCpp</span>(<span class="st">&#39;../src/SA22204174Rcpp.cpp&#39;</span>)</span></code></pre></div>
<pre><code>## Warning in normalizePath(path.expand(path), winslash, mustWork):
## path[1]=&quot;D:/user_student/hw/Statistical_calculation/final/SA22204174/src/../inst/include&quot;:
## 系统找不到指定的文件。</code></pre>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="fu">mixmodel_Rcpp</span>(X, K, <span class="fl">1e5</span>, initial_tau, initial_mu, initial_sigma)</span></code></pre></div>
<pre><code>## $iterations
## [1] 1519
## 
## $tau
## [1] 0.3188513 0.1908240 0.4903247
## 
## $mu
## [1] -1.9653389  0.4520905  3.1680911
## 
## $sigma
## [1] 1.0433739 0.7609533 0.7668253</code></pre>
</div>
</div>
<div id="the-concave-pairwise-fusion-approach" class="section level1">
<h1>The concave pairwise fusion approach</h1>
<div id="model-1" class="section level2">
<h2>Model</h2>
<p>Ma and Huang (2017) proposed a concave pairwise fusion penalized
least squares approach to subgroup analysis to deal with this problem.
One of the models considered in this article is that <span class="math display">\[y_i=\mu_i+\mathbf{x}_i^T\mathbf{\beta}+\epsilon_i,\,
i=1,\dots,n,\]</span> i.e. <span class="math display">\[\mathbf{y}=\begin{pmatrix}y_1\\y_2\\\vdots\\y_n\end{pmatrix}=\mathbf{\mu}+\mathbf{X}\beta+\epsilon=\begin{pmatrix}\mu_1\\\mu_2\\\vdots\\\mu_n\end{pmatrix}+\begin{pmatrix}\mathbf{x}_1^T\\\mathbf{x}_2^T\\\vdots\\\mathbf{x}_n^T\end{pmatrix}\beta+\begin{pmatrix}\epsilon_1\\\epsilon_2\\\vdots\\\epsilon_n\end{pmatrix}=\begin{pmatrix}\mu_1\\\mu_2\\\vdots\\\mu_n\end{pmatrix}+\begin{pmatrix}x_{11}\
x_{12}\cdots x_{1p}\\x_{21}\ x_{22}\cdots x_{2p}\\\vdots\\x_{n1}\
x_{n2}\cdots
x_{np}\end{pmatrix}\begin{pmatrix}\beta_1\\\beta_2\\\vdots\\\beta_p\end{pmatrix}+\begin{pmatrix}\epsilon_1\\\epsilon_2\\\vdots\\\epsilon_n\end{pmatrix}.\]</span>
It is also assumed that <span class="math inline">\(\mathbf{y}=(y_1,\dots,y_n)^T\)</span> are from
<span class="math inline">\(K\geq1\)</span> different groups and the
data from the same group have the same intercept. In other words, let
<span class="math inline">\(\mathcal{G}=(\mathcal{G}_1,\dots,\mathcal{G}_K)\)</span>
be a partition of <span class="math inline">\(\{1,\dots,n\}\)</span>. We
have <span class="math inline">\(\mu_i=\alpha_k\)</span> for all <span class="math inline">\(i\in\mathcal{G}_k\)</span>, where <span class="math inline">\(\alpha_k\)</span> is the common value for the
<span class="math inline">\(\mu_i\)</span>’s from group <span class="math inline">\(\mathcal{G}_k\)</span>. In practice, the number of
groups <span class="math inline">\(K\)</span> is unknown. However, it is
usually reasonable to assume that K is much smaller than n. The goal of
this paper is to estimate <span class="math inline">\(K\)</span> and
identify the subgroups of outcomes.</p>
</div>
<div id="method-1" class="section level2">
<h2>Method</h2>
<p>The idea is to minimize the objective function <span class="math display">\[Q_n(\mathbf{\mu},\mathbf{\beta};\lambda)=\frac{1}{2}\sum_{i=1}^n(y_i-\mu_i-\mathbf{x}_i^T\mathbf{\beta})^2+\sum_{1\leq
i&lt;j\leq n}p(|\mu_i-\mu_j|,\lambda),\]</span> where <span class="math inline">\(p(\cdot,\lambda)\)</span> is a concave penalty
function with a tuning parameter <span class="math inline">\(\lambda\geq
0\)</span>.</p>
<p>For a given <span class="math inline">\(\lambda&gt;0\)</span>, define
<span class="math display">\[(\hat\mu(\lambda),\hat\beta(\lambda))=\mathrm{argmin}_{\mu,\beta}Q_n(\mu,\beta;\lambda).\]</span>
The penalty shrinks some of the pairs <span class="math inline">\(\mu_j-\mu_k\)</span> to zero. Based on this, we
can partition the sample into subgroups. Specifically, let <span class="math inline">\(\hat\lambda\)</span> be the value of the tuning
parameter selected based on a data-driven procedure such as the BIC. For
simplicity, write <span class="math inline">\((\hat\mu,\hat\beta)=(\hat\mu(\hat\lambda),\hat\beta(\hat\lambda))\)</span>.
Let <span class="math inline">\(\{\hat\alpha_1,\dots,\hat\alpha_{\hat
K}\}\)</span> be the distinct values of <span class="math inline">\(\hat\mu\)</span>. Let <span class="math inline">\(\hat{\mathcal{G}}_{k}=\{i:\hat\mu_i=\hat\alpha_k,1\leq
i\leq n\},1\leq k\leq\hat K\)</span>. Then <span class="math inline">\(\{\hat{\mathcal{G}}_1,\dots,\hat{\mathcal{G}}_{\hat
K}\}\)</span> constitutes a partition of <span class="math inline">\(\{1,\dots,n\}\)</span>.</p>
<p>Three kinds of penalty function are used.</p>
<ol style="list-style-type: decimal">
<li><p>The <span class="math inline">\(L_1\)</span> penalty <span class="math display">\[p_{\gamma}(t,\lambda)=p(t,\lambda)=\lambda
t.\]</span></p></li>
<li><p>some concave penalty: SCAD <span class="math display">\[p_{\gamma}(t,\lambda)=\lambda\int_{0}^t(1-x/(\gamma\lambda))_+\mathrm{d}x,\,
\gamma&gt;1,\]</span></p></li>
<li><p>some concave penalty: MCP <span class="math display">\[p_{\gamma}(t,\lambda)=\lambda\int_{0}^t\min
\left\{1,\frac{(\gamma-x/\lambda)_+}{\gamma-1}\right\},\,
\gamma&gt;2,\]</span> where <span class="math inline">\(\gamma\)</span>
is a parameter that controls the concavity of the penalty
function.</p></li>
</ol>
<p>By the augmented Lagrangian method, the estimates of the parameters
can be obtained by minimizing <span class="math display">\[L(\mathbf{\mu},\mathbf{\beta},\mathbf{\eta},\mathbf{\upsilon})=S(\mathbf{\mu},\mathbf{\beta},\mathbf{\eta})+\sum_{i&lt;j}\upsilon_{ij}(\mu_i-\mu_j-\eta_{ij})+\frac{\vartheta}{2}\sum_{i&lt;j}(\mu_i-\mu_j-\eta_{ij})^2\\
=\frac{1}{2}\sum_{i=1}^n(y_i-\mu_i-\mathbf{x}_i^T\mathbf{\beta})^2+\sum_{i&lt;j}p_{\gamma}(|\eta_{ij}|,\lambda)+\sum_{i&lt;j}\upsilon_{ij}(\mu_i-\mu_j-\eta_{ij})+\frac{\vartheta}{2}\sum_{i&lt;j}(\mu_i-\mu_j-\eta_{ij})^2,\]</span>
where <span class="math inline">\(\mathbf{\eta}=\{\eta_{ij},
i&lt;j\}^T\)</span>, <span class="math inline">\(\eta_{ij}=\mu_i-\mu_i,
1\leq i&lt;j\leq n\)</span>, the dual variables <span class="math inline">\(\mathbf{\upsilon}=\{\upsilon_{ij},i&lt;j\}^T\)</span>
are Lagrange multipliers and <span class="math inline">\(\vartheta\)</span> is the penalty parameter.</p>
<p>Given <span class="math inline">\((\mathbf{\mu},\mathbf{\beta},\mathbf{\upsilon})\)</span>,
the minimization problem is the same as minimizing <span class="math display">\[\frac{\vartheta}{2}(\delta_{ij}-\eta_{ij})^2+p_{\gamma}(|\eta_{ij}|,\lambda)\]</span>
w.r.t. <span class="math inline">\(\eta_{ij}\)</span>, where <span class="math inline">\(\delta_{ij}=\mu_i-\mu_j+\vartheta^{-1}\upsilon_{ij}\)</span>.
The closed-form solution are as follows.</p>
<ol style="list-style-type: decimal">
<li><p><span class="math inline">\(L_1\)</span> penalty <span class="math display">\[\hat{\eta}_{ij}=\mathrm{ST}(\delta_{ij},\lambda/\vartheta),\]</span>
where <span class="math inline">\(\mathrm{ST}(t,\lambda)=\mathrm{sign}(t)(|t|-\lambda)_+\)</span>
is the soft thresholding rule.</p></li>
<li><p>MCP penalty with <span class="math inline">\(\gamma&gt;1/\vartheta\)</span> <span class="math display">\[\hat{\eta}_{ij}=\left\{\begin{array}{ll}
\frac{\mathrm{ST}(\delta_{ij},\lambda/\vartheta)}{1-1/(\gamma\vartheta)},
&amp; |\delta_{ij}|\leq\gamma\lambda, \\
\delta_{ij}, &amp; |\delta_{ij}|&gt;\gamma\lambda.
\end{array}\right.\]</span></p></li>
<li><p>SCAD penalty with <span class="math inline">\(\gamma&gt;1/\vartheta+1\)</span> <span class="math display">\[\hat{\eta}_{ij}=\left\{\begin{array}{ll}
\mathrm{ST}(\delta_{ij},\lambda/\vartheta), &amp;
|\delta_{ij}|\leq\lambda+\lambda/\vartheta, \\
\frac{\mathrm{ST}(\delta_{ij},\gamma\lambda/((\gamma-1)\vartheta))}{1-1/((\gamma-1)\vartheta)},
&amp; |\delta_{ij}|\leq\gamma\lambda, \\
\delta_{ij}, &amp; |\delta_{ij}|&gt;\gamma\lambda.
\end{array}\right.\]</span></p></li>
</ol>
</div>
<div id="algorithm-1" class="section level2">
<h2>Algorithm</h2>
<p>Use ADMM method to iteratively update <span class="math inline">\(\mathbf{\mu},\mathbf{\beta},\mathbf{\eta},\mathbf{\upsilon}\)</span>.</p>
<ol style="list-style-type: decimal">
<li><p>Initial estimates: <span class="math inline">\(\mathbf{\beta}^{(0)}\)</span> from least squares
regression by letting <span class="math inline">\(\mu_i=\mu\)</span> for
all <span class="math inline">\(i\)</span>, <span class="math inline">\(\mathbf{\mu}^{(0)}=\mathbf{y}-\mathbf{X}\mathbf{\beta}^{(0)},
\eta_{ij}^{(0)}=\mu_i^{(0)}-\mu_j^{(0)},\mathbf{\upsilon}^{(0)}=\mathbf{0}\)</span>.</p></li>
<li><p>At iteration <span class="math inline">\(m + 1\)</span>, compute
<span class="math inline">\((\mathbf{\mu}^{(m+1)},\mathbf{\beta}^{(m+1)},\mathbf{\eta}^{(m+1)},\mathbf{\upsilon}^{(m+1)})\)</span>
by the ADMM method.</p></li>
</ol>
<p>2.1. Update <span class="math inline">\(\mathbf{\mu},\mathbf{\beta}\)</span>: <span class="math display">\[\mathbf{\mu}^{(m+1)}=(\vartheta\Delta^T\Delta+\mathbf{I}_n-\mathbf{Q}_x)^{-1}\cdot\{(\mathbf{I}_n-\mathbf{Q}_x)\mathbf{y}+\vartheta\Delta^T(\mathbf{\eta}^{(m)}-\vartheta^{-1}\mathbf{\upsilon}^{(m)})\},\\
\mathbf{\beta}^{(m+1)}=(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{X}^T(\mathbf{y}-\mathbf{\mu}^{(m+1)}),\]</span>
where <span class="math inline">\(\Delta=\{e_i-e_j,i&lt;j\}^T\)</span>
and <span class="math inline">\(\mathbf{Q}_x=\mathbf{X}(\mathbf{X}^T\mathbf{X})^{-1}\mathbf{X}^T\)</span>.</p>
<p>2.2. update <span class="math inline">\(\mathbf{\eta}\)</span>: <span class="math display">\[\delta_{ij}^{(m+1)}=\mu_i^{(m+1)}-\mu_j^{(m+1)}+\vartheta^{-1}\upsilon_{ij}^{(m)},\]</span>
<span class="math inline">\(\eta_{ij}^{(m+1)}\)</span> is obtained by
the formula given above.</p>
<p>2.3. update <span class="math inline">\(\mathbf{\upsilon}\)</span>:
<span class="math display">\[\upsilon_{ij}^{(m+1)}=\upsilon_{ij}^{(m)}+\vartheta\{\mu_i^{(m+1)}-\mu_j^{(m+1)}-\eta_{ij}^{(m+1)}\}.\]</span></p>
<ol start="3" style="list-style-type: decimal">
<li>Terminate the algorithm if the stopping rule is met at step <span class="math inline">\(m + 1\)</span>. Then <span class="math inline">\((\mathbf{\mu}^{(m+1)},\mathbf{\beta}^{(m+1)},\mathbf{\eta}^{(m+1)},\mathbf{\upsilon}^{(m+1)})\)</span>
are our final estimates <span class="math inline">\((\hat{\mathbf{\mu}},\hat{\mathbf{\beta}},\hat{\mathbf{\eta}},\hat{\mathbf{\upsilon}})\)</span>.</li>
</ol>
<p>Otherwise, we go to Step 2.</p>
</div>
<div id="function" class="section level2">
<h2>Function</h2>
<p>We implement the the performance of the estimators with the ADMM
algorithm by using penalty MCP, and for other penalties the functions
are the same.</p>
<ul>
<li>Input:
<ul>
<li>X: independent variables of linear regression model, data structure:
<span class="math inline">\(n\times p\)</span>-dimensional matrix.</li>
<li>y: dependent variables of linear regression model, data structure:
<span class="math inline">\(n\times1\)</span>-dimensional matrix, or
<span class="math inline">\(n\)</span>-dimensiobal vector.</li>
<li>times: the upper bound on the number of iterations, data structure:
int.</li>
<li>vartheta, gamma, lambda: parameters of the penalty function, data
structure: numeric.</li>
</ul></li>
<li>Output: a list including
<ul>
<li>iterations: the number of iterations, data structure: int.</li>
<li>mu: The estimator <span class="math inline">\(\hat\mu\)</span>, data
structure: <span class="math inline">\(n\)</span>-dimensional
vector.</li>
<li>beta: The estimator <span class="math inline">\(\hat\beta\)</span>,
data structure: <span class="math inline">\(p\times1\)</span>-dimensional matrix.</li>
</ul></li>
</ul>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a>concavefusion <span class="ot">&lt;-</span> <span class="cf">function</span>(X, y, <span class="at">times =</span> <span class="fl">1e6</span>, vartheta, gamma, lambda){</span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a>  <span class="co">#X: independent variables of linear regression model, data structure: n*p-dimensional matrix, n-dimensional vector(p=1)</span></span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a>  <span class="co">#y: dependent variables of linear regression model, data structure: n*1-dimensional matrix, n-dimensional vector</span></span>
<span id="cb14-4"><a href="#cb14-4" tabindex="-1"></a>  <span class="co">#times: the upper bound on the number of iterations, data structure: int</span></span>
<span id="cb14-5"><a href="#cb14-5" tabindex="-1"></a>  <span class="co">#vartheta, gamma, lambda: parameters of the penalty function, data structure: numeric</span></span>
<span id="cb14-6"><a href="#cb14-6" tabindex="-1"></a>  n <span class="ot">&lt;-</span> <span class="fu">nrow</span>(X) <span class="co">#sample size</span></span>
<span id="cb14-7"><a href="#cb14-7" tabindex="-1"></a>  rate <span class="ot">&lt;-</span> <span class="fl">1e-8</span> <span class="co">#Convergence is checked when the change of elements in the sequence is small enough</span></span>
<span id="cb14-8"><a href="#cb14-8" tabindex="-1"></a></span>
<span id="cb14-9"><a href="#cb14-9" tabindex="-1"></a>  <span class="co">#the deterministic matrices that will be used in the iteration</span></span>
<span id="cb14-10"><a href="#cb14-10" tabindex="-1"></a>  deltaT <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="dv">0</span>, <span class="at">nrow =</span> n, <span class="at">ncol =</span> n<span class="sc">*</span>(n<span class="dv">-1</span>)<span class="sc">/</span><span class="dv">2</span>)</span>
<span id="cb14-11"><a href="#cb14-11" tabindex="-1"></a>  <span class="co">#deltaT[1,1:(n-1)] &lt;- 1</span></span>
<span id="cb14-12"><a href="#cb14-12" tabindex="-1"></a>  <span class="co">#for(j in 2:n){deltaT[j,j-1] &lt;- -1}</span></span>
<span id="cb14-13"><a href="#cb14-13" tabindex="-1"></a>  <span class="co">#for(i in 2:(n-1)){para_delta[i,(sum((n-i+1):(n-1))+1):(sum((n-i):(n-1)))] &lt;- 1}</span></span>
<span id="cb14-14"><a href="#cb14-14" tabindex="-1"></a>  <span class="co">#for(j in 2:n){para_delta[j,j:n] &lt;- -1}</span></span>
<span id="cb14-15"><a href="#cb14-15" tabindex="-1"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>(n<span class="dv">-1</span>)){</span>
<span id="cb14-16"><a href="#cb14-16" tabindex="-1"></a>    <span class="cf">for</span>(j <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>(n<span class="sc">-</span>i)){</span>
<span id="cb14-17"><a href="#cb14-17" tabindex="-1"></a>      deltaT[i,(<span class="dv">2</span><span class="sc">*</span>n<span class="sc">-</span>i)<span class="sc">*</span>(i<span class="dv">-1</span>)<span class="sc">/</span><span class="dv">2</span><span class="sc">+</span>j] <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb14-18"><a href="#cb14-18" tabindex="-1"></a>      deltaT[i<span class="sc">+</span>j,(<span class="dv">2</span><span class="sc">*</span>n<span class="sc">-</span>i)<span class="sc">*</span>(i<span class="dv">-1</span>)<span class="sc">/</span><span class="dv">2</span><span class="sc">+</span>j] <span class="ot">&lt;-</span> <span class="sc">-</span><span class="dv">1</span></span>
<span id="cb14-19"><a href="#cb14-19" tabindex="-1"></a>    }</span>
<span id="cb14-20"><a href="#cb14-20" tabindex="-1"></a>  }</span>
<span id="cb14-21"><a href="#cb14-21" tabindex="-1"></a>  deltaTdelta <span class="ot">&lt;-</span> <span class="fu">tcrossprod</span>(deltaT)</span>
<span id="cb14-22"><a href="#cb14-22" tabindex="-1"></a>  Qx <span class="ot">&lt;-</span> X <span class="sc">%*%</span> <span class="fu">solve</span>(<span class="fu">crossprod</span>(X)) <span class="sc">%*%</span><span class="fu">t</span>(X)</span>
<span id="cb14-23"><a href="#cb14-23" tabindex="-1"></a>  para.mu <span class="ot">&lt;-</span> <span class="fu">solve</span>(vartheta<span class="sc">*</span>deltaTdelta <span class="sc">+</span> <span class="fu">diag</span>(<span class="dv">1</span>, n) <span class="sc">-</span> Qx)</span>
<span id="cb14-24"><a href="#cb14-24" tabindex="-1"></a>  para.beta <span class="ot">&lt;-</span> <span class="fu">solve</span>(<span class="fu">crossprod</span>(X))</span>
<span id="cb14-25"><a href="#cb14-25" tabindex="-1"></a></span>
<span id="cb14-26"><a href="#cb14-26" tabindex="-1"></a>  <span class="co">#initialization</span></span>
<span id="cb14-27"><a href="#cb14-27" tabindex="-1"></a>  X1 <span class="ot">&lt;-</span> <span class="fu">cbind</span>(<span class="dv">1</span>, X)</span>
<span id="cb14-28"><a href="#cb14-28" tabindex="-1"></a>  initial <span class="ot">&lt;-</span> <span class="fu">solve</span>(<span class="fu">crossprod</span>(X1)) <span class="sc">%*%</span> (<span class="fu">crossprod</span>(X1, y))</span>
<span id="cb14-29"><a href="#cb14-29" tabindex="-1"></a>  mupast <span class="ot">&lt;-</span> <span class="fu">rep</span>(initial[<span class="dv">1</span>,], n)</span>
<span id="cb14-30"><a href="#cb14-30" tabindex="-1"></a>  betapast <span class="ot">&lt;-</span> initial[<span class="sc">-</span><span class="dv">1</span>,]</span>
<span id="cb14-31"><a href="#cb14-31" tabindex="-1"></a>  deltanew <span class="ot">&lt;-</span> etanew <span class="ot">&lt;-</span> etapast <span class="ot">&lt;-</span> upsilonnew <span class="ot">&lt;-</span> upsilonpast <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="dv">0</span>, <span class="at">nrow =</span> n, <span class="at">ncol =</span> n)</span>
<span id="cb14-32"><a href="#cb14-32" tabindex="-1"></a></span>
<span id="cb14-33"><a href="#cb14-33" tabindex="-1"></a>  <span class="co">#iteration</span></span>
<span id="cb14-34"><a href="#cb14-34" tabindex="-1"></a>  <span class="cf">for</span>(t <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>times){</span>
<span id="cb14-35"><a href="#cb14-35" tabindex="-1"></a>    <span class="co">#update mu</span></span>
<span id="cb14-36"><a href="#cb14-36" tabindex="-1"></a>    etapast.vector <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb14-37"><a href="#cb14-37" tabindex="-1"></a>    upsilonpast.vector <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb14-38"><a href="#cb14-38" tabindex="-1"></a>    <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>(n<span class="dv">-1</span>)){</span>
<span id="cb14-39"><a href="#cb14-39" tabindex="-1"></a>      <span class="cf">for</span>(j <span class="cf">in</span> (i<span class="sc">+</span><span class="dv">1</span>)<span class="sc">:</span>n){</span>
<span id="cb14-40"><a href="#cb14-40" tabindex="-1"></a>        etapast.vector <span class="ot">&lt;-</span> <span class="fu">rbind</span>(etapast.vector, etapast[i,j])</span>
<span id="cb14-41"><a href="#cb14-41" tabindex="-1"></a>        upsilonpast.vector <span class="ot">&lt;-</span> <span class="fu">rbind</span>(upsilonpast.vector, upsilonpast[i,j])</span>
<span id="cb14-42"><a href="#cb14-42" tabindex="-1"></a>      }</span>
<span id="cb14-43"><a href="#cb14-43" tabindex="-1"></a>    }</span>
<span id="cb14-44"><a href="#cb14-44" tabindex="-1"></a>    etapast.vector <span class="ot">&lt;-</span> etapast.vector[<span class="sc">-</span><span class="dv">1</span>,]</span>
<span id="cb14-45"><a href="#cb14-45" tabindex="-1"></a>    upsilonpast.vector <span class="ot">&lt;-</span> upsilonpast.vector[<span class="sc">-</span><span class="dv">1</span>,]</span>
<span id="cb14-46"><a href="#cb14-46" tabindex="-1"></a></span>
<span id="cb14-47"><a href="#cb14-47" tabindex="-1"></a>    munew <span class="ot">&lt;-</span> para.mu <span class="sc">%*%</span> ((<span class="fu">diag</span>(<span class="dv">1</span>, n)<span class="sc">-</span>Qx) <span class="sc">%*%</span> y <span class="sc">+</span> vartheta<span class="sc">*</span>deltaT <span class="sc">%*%</span> (etapast.vector<span class="sc">-</span>upsilonpast.vector<span class="sc">/</span>vartheta))</span>
<span id="cb14-48"><a href="#cb14-48" tabindex="-1"></a></span>
<span id="cb14-49"><a href="#cb14-49" tabindex="-1"></a>    <span class="co">#update beta</span></span>
<span id="cb14-50"><a href="#cb14-50" tabindex="-1"></a>    betanew <span class="ot">&lt;-</span> para.beta <span class="sc">%*%</span> <span class="fu">crossprod</span>(X, (y<span class="sc">-</span>munew))</span>
<span id="cb14-51"><a href="#cb14-51" tabindex="-1"></a></span>
<span id="cb14-52"><a href="#cb14-52" tabindex="-1"></a>    <span class="co">#update eta</span></span>
<span id="cb14-53"><a href="#cb14-53" tabindex="-1"></a>    <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>n){</span>
<span id="cb14-54"><a href="#cb14-54" tabindex="-1"></a>      <span class="cf">for</span>(j <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>n){</span>
<span id="cb14-55"><a href="#cb14-55" tabindex="-1"></a>        deltanew[i,j] <span class="ot">&lt;-</span> munew[i] <span class="sc">-</span> munew[j] <span class="sc">+</span> upsilonpast[i,j]<span class="sc">/</span>vartheta</span>
<span id="cb14-56"><a href="#cb14-56" tabindex="-1"></a>        <span class="cf">if</span>(<span class="fu">abs</span>(deltanew[i,j]) <span class="sc">&lt;=</span> gamma<span class="sc">*</span>lambda){</span>
<span id="cb14-57"><a href="#cb14-57" tabindex="-1"></a>          etanew[i,j] <span class="ot">&lt;-</span> <span class="fu">sign</span>(deltanew[i,j])<span class="sc">*</span><span class="fu">max</span>(<span class="fu">abs</span>(deltanew[i,j])<span class="sc">-</span>lambda<span class="sc">/</span>vartheta,<span class="dv">0</span>) <span class="sc">/</span> (<span class="dv">1-1</span><span class="sc">/</span>gamma<span class="sc">/</span>vartheta)</span>
<span id="cb14-58"><a href="#cb14-58" tabindex="-1"></a>        }<span class="cf">else</span>{</span>
<span id="cb14-59"><a href="#cb14-59" tabindex="-1"></a>          etanew[i,j] <span class="ot">&lt;-</span> deltanew[i,j]</span>
<span id="cb14-60"><a href="#cb14-60" tabindex="-1"></a>        }</span>
<span id="cb14-61"><a href="#cb14-61" tabindex="-1"></a>      }</span>
<span id="cb14-62"><a href="#cb14-62" tabindex="-1"></a>    }</span>
<span id="cb14-63"><a href="#cb14-63" tabindex="-1"></a></span>
<span id="cb14-64"><a href="#cb14-64" tabindex="-1"></a>    <span class="co">#update upsilon</span></span>
<span id="cb14-65"><a href="#cb14-65" tabindex="-1"></a>    <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>n){</span>
<span id="cb14-66"><a href="#cb14-66" tabindex="-1"></a>      <span class="cf">for</span>(j <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>n){</span>
<span id="cb14-67"><a href="#cb14-67" tabindex="-1"></a>        upsilonnew[i,j] <span class="ot">&lt;-</span> upsilonpast[i,j] <span class="sc">+</span> vartheta<span class="sc">*</span>(munew[i]<span class="sc">-</span>munew[j]<span class="sc">-</span>etanew[i,j])</span>
<span id="cb14-68"><a href="#cb14-68" tabindex="-1"></a>      }</span>
<span id="cb14-69"><a href="#cb14-69" tabindex="-1"></a>    }</span>
<span id="cb14-70"><a href="#cb14-70" tabindex="-1"></a></span>
<span id="cb14-71"><a href="#cb14-71" tabindex="-1"></a>    <span class="co">#Check for convergence</span></span>
<span id="cb14-72"><a href="#cb14-72" tabindex="-1"></a>    <span class="cf">if</span> (<span class="fu">max</span>(<span class="fu">sum</span>(<span class="fu">abs</span>(munew <span class="sc">-</span> mupast))<span class="sc">/</span>(<span class="fu">sum</span>(<span class="fu">abs</span>(mupast))<span class="sc">+</span><span class="fl">1e-4</span>), <span class="fu">sum</span>(<span class="fu">abs</span>(betanew<span class="sc">-</span>betapast))<span class="sc">/</span>(<span class="fu">sum</span>(<span class="fu">abs</span>(betapast))<span class="sc">+</span><span class="fl">1e-4</span>), <span class="fu">sum</span>(<span class="fu">abs</span>(etanew<span class="sc">-</span>etapast))<span class="sc">/</span>(<span class="fu">sum</span>(<span class="fu">abs</span>(etapast))<span class="sc">+</span><span class="fl">1e-4</span>), <span class="fu">sum</span>(<span class="fu">abs</span>(upsilonnew<span class="sc">-</span>upsilonpast))<span class="sc">/</span>(<span class="fu">sum</span>(<span class="fu">abs</span>(upsilonpast))<span class="sc">+</span><span class="fl">1e-4</span>)) <span class="sc">&lt;</span> rate){</span>
<span id="cb14-73"><a href="#cb14-73" tabindex="-1"></a>      <span class="co">#cat(&quot;The sequence converges after&quot;, t, &quot;iterations.&quot;, &#39;\n&#39;)</span></span>
<span id="cb14-74"><a href="#cb14-74" tabindex="-1"></a>      <span class="cf">break</span></span>
<span id="cb14-75"><a href="#cb14-75" tabindex="-1"></a>    }<span class="cf">else</span>{</span>
<span id="cb14-76"><a href="#cb14-76" tabindex="-1"></a>      mupast <span class="ot">&lt;-</span> munew</span>
<span id="cb14-77"><a href="#cb14-77" tabindex="-1"></a>      betapast <span class="ot">&lt;-</span> betanew</span>
<span id="cb14-78"><a href="#cb14-78" tabindex="-1"></a>      etapast <span class="ot">&lt;-</span> etanew</span>
<span id="cb14-79"><a href="#cb14-79" tabindex="-1"></a>      upsilonpast <span class="ot">&lt;-</span> upsilonnew</span>
<span id="cb14-80"><a href="#cb14-80" tabindex="-1"></a>    }</span>
<span id="cb14-81"><a href="#cb14-81" tabindex="-1"></a>  }</span>
<span id="cb14-82"><a href="#cb14-82" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">list</span>(<span class="at">iterations =</span> t, <span class="at">mu =</span> munew, <span class="at">beta =</span> betanew))</span>
<span id="cb14-83"><a href="#cb14-83" tabindex="-1"></a>}</span></code></pre></div>
</div>
<div id="example" class="section level2">
<h2>Example</h2>
<div id="example-1.-1" class="section level3">
<h3>Example 1.</h3>
<p><span class="math inline">\(n=50,p=2,K=3\)</span>, <span class="math inline">\(\mu_1=-2,\mu_2=0,\mu_3=2\)</span>, <span class="math inline">\(P(\mu=\mu_1)=1/3, P(\mu=\mu_2)=1/3,
P(\mu=\mu_3)=1/3\)</span> and <span class="math inline">\(\Sigma\)</span> satisfies that <span class="math inline">\(\Sigma_{ii}=1, \Sigma_{ij}=0.3, i\neq
j\in\{1,2\}\)</span>.</p>
<p>we choose to fix the parameters of the penalty function that <span class="math inline">\(\vartheta=1\)</span>, <span class="math inline">\(\gamma=3\)</span> and <span class="math inline">\(\lambda=0.05\)</span>.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a><span class="co">#parameters of the samples</span></span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>n <span class="ot">&lt;-</span> <span class="dv">50</span>; p <span class="ot">&lt;-</span> <span class="dv">2</span>; K <span class="ot">&lt;-</span> <span class="dv">3</span></span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a>sigma <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fl">0.3</span>, <span class="at">nrow =</span> p, <span class="at">ncol =</span> p) <span class="sc">+</span> <span class="fu">diag</span>(<span class="fl">0.7</span>, p)</span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a>mu <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">2</span>,<span class="dv">0</span>,<span class="dv">2</span>)</span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a>beta <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">3</span>), <span class="at">nrow =</span> p, <span class="at">ncol =</span> <span class="dv">1</span>)</span>
<span id="cb15-6"><a href="#cb15-6" tabindex="-1"></a></span>
<span id="cb15-7"><a href="#cb15-7" tabindex="-1"></a><span class="co">#generate the samples</span></span>
<span id="cb15-8"><a href="#cb15-8" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb15-9"><a href="#cb15-9" tabindex="-1"></a>mu.sample <span class="ot">&lt;-</span> <span class="fu">sample</span>(mu, <span class="at">size =</span> n, <span class="at">replace =</span> <span class="cn">TRUE</span>, <span class="at">prob =</span> <span class="fu">c</span>(<span class="dv">1</span><span class="sc">/</span><span class="dv">3</span>,<span class="dv">1</span><span class="sc">/</span><span class="dv">3</span>,<span class="dv">1</span><span class="sc">/</span><span class="dv">3</span>))</span>
<span id="cb15-10"><a href="#cb15-10" tabindex="-1"></a>X <span class="ot">&lt;-</span> mvtnorm<span class="sc">::</span><span class="fu">rmvnorm</span>(n, <span class="at">mean =</span> <span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">0</span>), <span class="at">sigma =</span> sigma)</span>
<span id="cb15-11"><a href="#cb15-11" tabindex="-1"></a>y <span class="ot">&lt;-</span> mu.sample <span class="sc">+</span> X<span class="sc">%*%</span>beta <span class="sc">+</span> <span class="fu">rnorm</span>(n, <span class="at">mean =</span> <span class="dv">0</span>, <span class="at">sd =</span><span class="fl">0.5</span>)</span></code></pre></div>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a><span class="co">#parameters to be input in the function</span></span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a>vartheta <span class="ot">&lt;-</span> <span class="dv">1</span>; gamma <span class="ot">&lt;-</span> <span class="dv">3</span>; lambda <span class="ot">&lt;-</span> <span class="fl">0.05</span>; times <span class="ot">&lt;-</span> <span class="fl">1e4</span></span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a><span class="co">#using the function to implement subgroup analysis</span></span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a>result <span class="ot">&lt;-</span> <span class="fu">concavefusion</span>(X, y, times, vartheta, gamma, lambda)</span>
<span id="cb16-5"><a href="#cb16-5" tabindex="-1"></a><span class="co">#check whether the results accord with the theoretical value</span></span>
<span id="cb16-6"><a href="#cb16-6" tabindex="-1"></a>result<span class="sc">$</span>iterations; result<span class="sc">$</span>mu[mu.sample<span class="sc">==</span>mu[<span class="dv">1</span>]]; result<span class="sc">$</span>mu[mu.sample<span class="sc">==</span>mu[<span class="dv">2</span>]]; result<span class="sc">$</span>mu[mu.sample<span class="sc">==</span>mu[<span class="dv">3</span>]]; result<span class="sc">$</span>beta</span></code></pre></div>
<pre><code>## [1] 1201</code></pre>
<pre><code>##  [1] -2.2308221 -2.2308221 -2.2308221 -2.2308221 -2.2308221 -1.5268472
##  [7] -2.7898040 -2.2308221 -2.2308221 -2.2308221 -0.7995206 -2.2308221
## [13] -2.2308221 -1.5268472 -0.7995206 -2.2308221 -0.7995206 -2.2308221
## [19] -2.2308221</code></pre>
<pre><code>##  [1]  0.36823230 -0.06388482  0.18117277 -0.79952063 -0.06388482  1.80364943
##  [7] -0.79952063 -0.79952063 -0.06388482 -0.79952063  0.45913266 -0.06388482</code></pre>
<pre><code>##  [1] 1.803649 1.803649 1.803649 1.803649 1.803649 1.803649 1.803649 1.803649
##  [9] 1.803649 1.803649 1.803649 1.803649 1.803649 1.803649 1.803649 1.803649
## [17] 1.803649 1.803649 1.803649</code></pre>
<pre><code>##           [,1]
## [1,] 0.9232295
## [2,] 2.9893977</code></pre>
</div>
<div id="example-2.-1" class="section level3">
<h3>Example 2.</h3>
<p><span class="math inline">\(n=50,p=2,K=3\)</span>, <span class="math inline">\(\mu_1=-2,\mu_2=0,\mu_3=2\)</span>, <span class="math inline">\(P(\mu=\mu_1)=1/3, P(\mu=\mu_2)=1/3,
P(\mu=\mu_3)=1/3\)</span> and <span class="math inline">\(\Sigma\)</span> satisfies that <span class="math inline">\(\Sigma_{ii}=1, \Sigma_{ij}=0.3, i\neq
j\in\{1,2\}\)</span>.</p>
<p>we choose to fix the parameters of the penalty function that <span class="math inline">\(\vartheta=1\)</span>, <span class="math inline">\(\gamma=3\)</span> and <span class="math inline">\(\lambda=0.05\)</span>.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" tabindex="-1"></a><span class="co">#parameters of the samples</span></span>
<span id="cb22-2"><a href="#cb22-2" tabindex="-1"></a>n <span class="ot">&lt;-</span> <span class="dv">50</span>; p <span class="ot">&lt;-</span> <span class="dv">1</span>; K <span class="ot">&lt;-</span> <span class="dv">3</span></span>
<span id="cb22-3"><a href="#cb22-3" tabindex="-1"></a>sigma <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb22-4"><a href="#cb22-4" tabindex="-1"></a>mu <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">2</span>,<span class="dv">0</span>,<span class="dv">3</span>)</span>
<span id="cb22-5"><a href="#cb22-5" tabindex="-1"></a>beta <span class="ot">&lt;-</span> <span class="dv">2</span></span>
<span id="cb22-6"><a href="#cb22-6" tabindex="-1"></a></span>
<span id="cb22-7"><a href="#cb22-7" tabindex="-1"></a><span class="co">#generate the samples</span></span>
<span id="cb22-8"><a href="#cb22-8" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb22-9"><a href="#cb22-9" tabindex="-1"></a>mu.sample <span class="ot">&lt;-</span> <span class="fu">sample</span>(mu, <span class="at">size =</span> n, <span class="at">replace =</span> <span class="cn">TRUE</span>, <span class="at">prob =</span> <span class="fu">c</span>(<span class="fl">0.2</span>,<span class="fl">0.3</span>,<span class="fl">0.5</span>))</span>
<span id="cb22-10"><a href="#cb22-10" tabindex="-1"></a>X <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(n, <span class="at">mean =</span> <span class="dv">0</span>, <span class="at">sd =</span> <span class="fu">sqrt</span>(sigma))</span>
<span id="cb22-11"><a href="#cb22-11" tabindex="-1"></a>X <span class="ot">&lt;-</span> <span class="fu">matrix</span>(X, <span class="at">nrow =</span> n, <span class="at">ncol =</span> <span class="dv">1</span>)</span>
<span id="cb22-12"><a href="#cb22-12" tabindex="-1"></a>y <span class="ot">&lt;-</span> mu.sample <span class="sc">+</span> X<span class="sc">%*%</span>beta <span class="sc">+</span> <span class="fu">rnorm</span>(n, <span class="at">mean =</span> <span class="dv">0</span>, <span class="at">sd =</span><span class="fl">0.5</span>)</span></code></pre></div>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a><span class="co">#parameters to be input in the function</span></span>
<span id="cb23-2"><a href="#cb23-2" tabindex="-1"></a>vartheta <span class="ot">&lt;-</span> <span class="dv">1</span>; gamma <span class="ot">&lt;-</span> <span class="dv">3</span>; lambda <span class="ot">&lt;-</span> <span class="fl">0.05</span>; times <span class="ot">&lt;-</span> <span class="fl">1e4</span></span>
<span id="cb23-3"><a href="#cb23-3" tabindex="-1"></a><span class="co">#using the function to implement subgroup analysis</span></span>
<span id="cb23-4"><a href="#cb23-4" tabindex="-1"></a>result <span class="ot">&lt;-</span> <span class="fu">concavefusion</span>(X, y, times, vartheta, gamma, lambda)</span>
<span id="cb23-5"><a href="#cb23-5" tabindex="-1"></a><span class="co">#check whether the results accord with the theoretical value</span></span>
<span id="cb23-6"><a href="#cb23-6" tabindex="-1"></a>result<span class="sc">$</span>iterations; result<span class="sc">$</span>mu[mu.sample<span class="sc">==</span>mu[<span class="dv">1</span>]]; result<span class="sc">$</span>mu[mu.sample<span class="sc">==</span>mu[<span class="dv">2</span>]]; result<span class="sc">$</span>mu[mu.sample<span class="sc">==</span>mu[<span class="dv">3</span>]]; result<span class="sc">$</span>beta</span></code></pre></div>
<pre><code>## [1] 741</code></pre>
<pre><code>## [1] -2.001395 -2.216488 -2.001395 -1.398287 -1.742591 -2.001395 -1.163079
## [8] -2.216488</code></pre>
<pre><code>##  [1] -0.04720215 -0.04720215 -0.04720215 -0.04720215 -0.04720215 -0.04720215
##  [7]  0.77215990 -0.04720215 -0.04720215 -0.04720215 -0.04720215 -0.04720215
## [13] -0.04720215 -0.04720215 -0.04720215 -0.04720215 -0.04720215 -0.04720215
## [19] -0.04720215</code></pre>
<pre><code>##  [1] 3.049839 3.049839 3.049839 3.049839 3.049839 3.049839 3.049839 3.049839
##  [9] 3.049839 3.049839 3.049839 3.049839 3.049839 3.049839 3.049839 3.049839
## [17] 3.049839 3.049839 3.049839 3.049839 3.049839 3.049839 3.049839</code></pre>
<pre><code>##          [,1]
## [1,] 1.969136</code></pre>
</div>
</div>
</div>
<div id="comparison" class="section level1">
<h1>Comparison</h1>
<p>We compare the two approaches. In our regression setting, we need to
apply the mixture model approach to <span class="math inline">\(y_i-\mathbf{x}_i^T\beta\)</span> for cluster
analysis. One simple way is to obtain the estimate <span class="math inline">\(\hat{\beta}\)</span> of <span class="math inline">\(\beta\)</span> by the ordinary least squares (OLS)
first, and then apply the mixture model approach to the observations
<span class="math inline">\(y_i-\mathbf{x}_i^T\hat\beta\)</span>.</p>
<p><span class="math inline">\(n=50,p=2,K=3\)</span>, <span class="math inline">\(\mu_1=-2,\mu_2=0,\mu_3=2\)</span>, <span class="math inline">\(P(\mu=\mu_1)=1/3, P(\mu=\mu_2)=1/3,
P(\mu=\mu_3)=1/3\)</span> and <span class="math inline">\(\Sigma\)</span> satisfies that <span class="math inline">\(\Sigma_{ii}=1, \Sigma_{ij}=0.3, i\neq
j\in\{1,2\}\)</span>.</p>
<p>we choose to fix the parameters of the penalty function that <span class="math inline">\(\vartheta=1\)</span>, <span class="math inline">\(\gamma=3\)</span> and <span class="math inline">\(\lambda=0.05\)</span>.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" tabindex="-1"></a><span class="co">#parameters of the samples</span></span>
<span id="cb29-2"><a href="#cb29-2" tabindex="-1"></a>n <span class="ot">&lt;-</span> <span class="dv">30</span>; p <span class="ot">&lt;-</span> <span class="dv">1</span>; K <span class="ot">&lt;-</span> <span class="dv">3</span></span>
<span id="cb29-3"><a href="#cb29-3" tabindex="-1"></a>sigma <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb29-4"><a href="#cb29-4" tabindex="-1"></a>mu <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">2</span>,<span class="dv">0</span>,<span class="dv">3</span>)</span>
<span id="cb29-5"><a href="#cb29-5" tabindex="-1"></a>beta <span class="ot">&lt;-</span> <span class="dv">2</span></span>
<span id="cb29-6"><a href="#cb29-6" tabindex="-1"></a></span>
<span id="cb29-7"><a href="#cb29-7" tabindex="-1"></a><span class="co">#generate the samples</span></span>
<span id="cb29-8"><a href="#cb29-8" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb29-9"><a href="#cb29-9" tabindex="-1"></a>mu.sample <span class="ot">&lt;-</span> <span class="fu">sample</span>(mu, <span class="at">size =</span> n, <span class="at">replace =</span> <span class="cn">TRUE</span>, <span class="at">prob =</span> <span class="fu">c</span>(<span class="fl">0.2</span>,<span class="fl">0.3</span>,<span class="fl">0.5</span>))</span>
<span id="cb29-10"><a href="#cb29-10" tabindex="-1"></a>X <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(n, <span class="at">mean =</span> <span class="dv">0</span>, <span class="at">sd =</span> <span class="fu">sqrt</span>(sigma))</span>
<span id="cb29-11"><a href="#cb29-11" tabindex="-1"></a>X <span class="ot">&lt;-</span> <span class="fu">matrix</span>(X, <span class="at">nrow =</span> n, <span class="at">ncol =</span> <span class="dv">1</span>)</span>
<span id="cb29-12"><a href="#cb29-12" tabindex="-1"></a>y <span class="ot">&lt;-</span> mu.sample <span class="sc">+</span> X<span class="sc">%*%</span>beta <span class="sc">+</span> <span class="fu">rnorm</span>(n, <span class="at">mean =</span> <span class="dv">0</span>, <span class="at">sd =</span><span class="fl">0.5</span>)</span>
<span id="cb29-13"><a href="#cb29-13" tabindex="-1"></a>X1 <span class="ot">&lt;-</span> <span class="fu">cbind</span>(<span class="dv">1</span>, X)</span>
<span id="cb29-14"><a href="#cb29-14" tabindex="-1"></a>betahat <span class="ot">&lt;-</span> (<span class="fu">solve</span>(<span class="fu">crossprod</span>(X1))<span class="sc">%*%</span><span class="fu">crossprod</span>(X1,y))[<span class="dv">2</span>,<span class="dv">1</span>]</span>
<span id="cb29-15"><a href="#cb29-15" tabindex="-1"></a>Xhat <span class="ot">&lt;-</span> y<span class="sc">-</span>X<span class="sc">*</span>betahat</span></code></pre></div>
<p>The results given from the mixture models approach are as
follows.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" tabindex="-1"></a><span class="co">#initialization</span></span>
<span id="cb30-2"><a href="#cb30-2" tabindex="-1"></a>initial_tau <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="dv">1</span><span class="sc">/</span>K, K)</span>
<span id="cb30-3"><a href="#cb30-3" tabindex="-1"></a>initial_mu <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb30-4"><a href="#cb30-4" tabindex="-1"></a>initial_sigma <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="fu">var</span>(Xhat),K)</span>
<span id="cb30-5"><a href="#cb30-5" tabindex="-1"></a><span class="co">#using the function to implement subgroup analysis</span></span>
<span id="cb30-6"><a href="#cb30-6" tabindex="-1"></a><span class="fu">mixmodel_R</span>(Xhat, K, <span class="fl">1e5</span>, initial_tau, initial_mu, initial_sigma)</span></code></pre></div>
<pre><code>## $iterations
## [1] 37
## 
## $tau
## [1] 0.2000000 0.2666641 0.5333359
## 
## $mu
## [1] -2.2054366  0.1197801  3.1342861
## 
## $sigma
## [1] 0.12235203 0.06809189 0.22696012</code></pre>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" tabindex="-1"></a><span class="fu">library</span>(Rcpp)</span>
<span id="cb32-2"><a href="#cb32-2" tabindex="-1"></a><span class="fu">sourceCpp</span>(<span class="st">&#39;../src/SA22204174Rcpp.cpp&#39;</span>)</span>
<span id="cb32-3"><a href="#cb32-3" tabindex="-1"></a><span class="fu">mixmodel_Rcpp</span>(<span class="fu">c</span>(Xhat), K, <span class="fl">1e5</span>, initial_tau, initial_mu, initial_sigma)</span></code></pre></div>
<pre><code>## $iterations
## [1] 37
## 
## $tau
## [1] 0.2000000 0.2666641 0.5333359
## 
## $mu
## [1] -2.2054366  0.1197801  3.1342861
## 
## $sigma
## [1] 0.12235203 0.06809189 0.22696012</code></pre>
<p>The results from the concave pairwise fusion approach are as
follows.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" tabindex="-1"></a><span class="co">#parameters to be input in the function</span></span>
<span id="cb34-2"><a href="#cb34-2" tabindex="-1"></a>vartheta <span class="ot">&lt;-</span> <span class="dv">1</span>; gamma <span class="ot">&lt;-</span> <span class="dv">3</span>; lambda <span class="ot">&lt;-</span> <span class="fl">0.05</span>; times <span class="ot">&lt;-</span> <span class="fl">1e4</span></span>
<span id="cb34-3"><a href="#cb34-3" tabindex="-1"></a><span class="co">#using the function to implement subgroup analysis</span></span>
<span id="cb34-4"><a href="#cb34-4" tabindex="-1"></a>result <span class="ot">&lt;-</span> <span class="fu">concavefusion</span>(X, y, times, vartheta, gamma, lambda)</span>
<span id="cb34-5"><a href="#cb34-5" tabindex="-1"></a><span class="co">#check whether the results accord with the theoretical value</span></span>
<span id="cb34-6"><a href="#cb34-6" tabindex="-1"></a>result<span class="sc">$</span>iterations; result<span class="sc">$</span>mu[mu.sample<span class="sc">==</span>mu[<span class="dv">1</span>]]; result<span class="sc">$</span>mu[mu.sample<span class="sc">==</span>mu[<span class="dv">2</span>]]; result<span class="sc">$</span>mu[mu.sample<span class="sc">==</span>mu[<span class="dv">3</span>]]; result<span class="sc">$</span>beta</span></code></pre></div>
<pre><code>## [1] 702</code></pre>
<pre><code>## [1] -2.317519 -2.093403 -2.599561 -1.776019 -1.776019 -2.599561</code></pre>
<pre><code>## [1] 0.01775465 0.01775465 0.01775464 0.01775464 0.01775465 0.01775465 0.01775464
## [8] 0.75165334</code></pre>
<pre><code>##  [1] 2.714221 3.168758 3.168758 3.478142 4.008062 2.714221 3.478142 3.805928
##  [9] 3.168758 2.223000 2.714221 3.805928 3.168758 2.714221 3.168758 2.714221</code></pre>
<pre><code>##         [,1]
## [1,] 2.31824</code></pre>
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" tabindex="-1"></a><span class="co">#compare.time &lt;- microbenchmark::microbenchmark(mixmodel_R = mixmodel_R(Xhat, K, 1e5, initial_tau, initial_mu, initial_sigma), mixmodel_Rcpp = mixmodel_Rcpp(c(Xhat), K, 1e5, initial_tau, initial_mu, initial_sigma), concavefusion = concavefusion(X, y, times, vartheta, gamma, lambda))</span></span>
<span id="cb40-2"><a href="#cb40-2" tabindex="-1"></a><span class="co">#summary(compare.time)[,c(1,3,5,6)]</span></span></code></pre></div>
<p>Because this calculation takes too much time, we skipped it when
generating the R package, and the result is shown in the table
below.</p>
<table>
<thead>
<tr class="header">
<th align="left">expr</th>
<th align="right">lq</th>
<th align="right">median</th>
<th align="right">uq</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">mixmodel_R</td>
<td align="right">9.79450</td>
<td align="right">11.7156</td>
<td align="right">14.16805</td>
</tr>
<tr class="even">
<td align="left">mixmodel_Rcpp</td>
<td align="right">2.09255</td>
<td align="right">2.6182</td>
<td align="right">3.14655</td>
</tr>
<tr class="odd">
<td align="left">concavefusion</td>
<td align="right">7072.90970</td>
<td align="right">7406.3218</td>
<td align="right">8616.48340</td>
</tr>
</tbody>
</table>
<p>From the time compared above, we find that the mixture model approach
is faster than the concave pairwise fusion approach in this case.</p>
<p>But the most important difference between these two approaches is the
scope of application rather than the speed of calculation. The mixture
model-based approach as a supervised clustering method needs to specify
an underlying distribution for the data, such as Gaussian distribution,
and also requires specification of the number of mixture components in
the population. But the concave pairwise fusion approach is able to
automatically detect and identify subgroups based on a concave pairwise
fusion penalty without knowledge of an a priori classification or a
natural basis for separating a sample into subsets.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" tabindex="-1"></a><span class="fu">detach</span>(package<span class="sc">:</span>Rcpp)</span>
<span id="cb41-2"><a href="#cb41-2" tabindex="-1"></a><span class="fu">rm</span>(<span class="at">list =</span> <span class="fu">ls</span>())</span></code></pre></div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
